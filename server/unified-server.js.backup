import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import * as Y from 'yjs';
import * as encoding from 'lib0/encoding';
import * as decoding from 'lib0/decoding';
import * as syncProtocol from 'y-protocols/sync';
import * as awarenessProtocol from 'y-protocols/awareness';

// Types deconst PORT = process.env.PORT || 3001;
const HOST = process.env.HOST || '0.0.0.0';
server.listen(PORT, HOST, () => {
  console.log(`ðŸš€ Serveur unifiÃ© Synkro dÃ©marrÃ© sur ${HOST}:${PORT}`);
  console.log(`ðŸ“ Collaboration Yjs: ws://localhost:${PORT}/yjs/ROOM_ID`);
  console.log(`ðŸŽ¨ Whiteboard: ws://localhost:${PORT}/whiteboard`);
});ges Yjs
const messageSync = 0;
const messageAwareness = 1;
const messageQueryAwareness = 3;

// Store pour les documents Yjs et awareness par room
const documents = new Map();
const awarenesses = new Map();

// Store pour les salles whiteboard
const whiteboardRooms = new Map();

function getDocument(roomname) {
  if (!documents.has(roomname)) {
    console.log(`?? Crï¿½ation du document Yjs pour la room: ${roomname}`);
    const doc = new Y.Doc();
    documents.set(roomname, doc);
    const awareness = new awarenessProtocol.Awareness(doc);
    awarenesses.set(roomname, awareness);
  }
  return documents.get(roomname);
}

function getAwareness(roomname) {
  getDocument(roomname); // S'assurer que l'awareness existe
  return awarenesses.get(roomname);
}

// Fonction pour diffuser aux clients Yjs de la mï¿½me room
function broadcastToYjsRoom(roomname, message, sender) {
  yjsWss.clients.forEach(client => {
    if (client.roomname === roomname && client !== sender && client.readyState === 1) {
      client.send(message);
    }
  });
}

// Fonction pour diffuser aux clients whiteboard de la mï¿½me room
function broadcastToWhiteboardRoom(roomId, message, excludeClient = null) {
  const room = whiteboardRooms.get(roomId);
  if (room) {
    room.clients.forEach(client => {
      if (client.ws !== excludeClient && client.ws.readyState === 1) {
        try {
          client.ws.send(JSON.stringify(message));
        } catch (error) {
          console.error('? Erreur envoi message whiteboard:', error);
        }
      }
    });
  }
}

// Gestionnaire de connexions Yjs
function handleYjsConnection(ws, request) {
  const url = new URL(request.url, 'http://localhost');
  const roomname = url.pathname.slice(1); // Retirer le '/' du dï¿½but

  console.log(`?? Nouvelle connexion Yjs pour la room: ${roomname}`);

  const doc = getDocument(roomname);
  const awareness = getAwareness(roomname);

  ws.roomname = roomname;
  ws.doc = doc;
  ws.awareness = awareness;

  ws.on('error', (error) => {
    console.error(`? Erreur WebSocket Yjs pour la room ${roomname}:`, error);
  });

  ws.on('message', (data) => {
    try {
      const uint8Array = new Uint8Array(data);
      const decoder = decoding.createDecoder(uint8Array);
      const encoder = encoding.createEncoder();

      const messageType = decoding.readVarUint(decoder);

      switch (messageType) {
        case messageSync:
          console.log(`?? Message SYNC pour la room ${roomname}`);
          encoding.writeVarUint(encoder, messageSync);
          syncProtocol.readSyncMessage(decoder, encoder, doc, ws);
          break;

        case messageAwareness:
          console.log(`??? Message AWARENESS pour la room ${roomname}`);
          awarenessProtocol.applyAwarenessUpdate(
            awareness,
            decoding.readVarUint8Array(decoder),
            ws
          );
          break;

        case messageQueryAwareness:
          console.log(`? Message QUERY_AWARENESS pour la room ${roomname}`);
          encoding.writeVarUint(encoder, messageAwareness);
          encoding.writeVarUint8Array(
            encoder,
            awarenessProtocol.encodeAwarenessUpdate(
              awareness,
              Array.from(awareness.getStates().keys())
            )
          );
          break;

        default:
          console.log(`?? Type de message Yjs inconnu: ${messageType}`);
      }

      if (encoding.length(encoder) > 1) {
        ws.send(encoding.toUint8Array(encoder));
      }
    } catch (error) {
      console.error(`? Erreur traitement message Yjs pour la room ${roomname}:`, error);
    }
  });

  // Gestionnaires de mise ï¿½ jour
  const updateHandler = (update, origin) => {
    if (origin !== ws) {
      const encoder = encoding.createEncoder();
      encoding.writeVarUint(encoder, messageSync);
      syncProtocol.writeUpdate(encoder, update);
      const message = encoding.toUint8Array(encoder);
      broadcastToYjsRoom(roomname, message, ws);
    }
  };

  const awarenessUpdateHandler = ({ added, updated, removed }, origin) => {
    if (origin !== ws) {
      const changedClients = added.concat(updated).concat(removed);
      const encoder = encoding.createEncoder();
      encoding.writeVarUint(encoder, messageAwareness);
      encoding.writeVarUint8Array(
        encoder,
        awarenessProtocol.encodeAwarenessUpdate(awareness, changedClients)
      );
      const message = encoding.toUint8Array(encoder);
      broadcastToYjsRoom(roomname, message, ws);
    }
  };

  doc.on('update', updateHandler);
  awareness.on('update', awarenessUpdateHandler);

  // Envoyer l'ï¿½tat initial
  const encoder = encoding.createEncoder();
  encoding.writeVarUint(encoder, messageSync);
  syncProtocol.writeSyncStep1(encoder, doc);
  ws.send(encoding.toUint8Array(encoder));

  // Nettoyage ï¿½ la dï¿½connexion
  ws.on('close', (code, reason) => {
    console.log(`?? Dï¿½connexion Yjs de la room: ${roomname} (code: ${code})`);
    doc.off('update', updateHandler);
    awareness.off('update', awarenessUpdateHandler);
    awarenessProtocol.removeAwarenessStates(
      awareness,
      [doc.clientID],
      'client disconnected'
    );
  });
}

// Gestionnaire de connexions whiteboard
function handleWhiteboardConnection(ws, request) {
  console.log('?? Nouvelle connexion whiteboard');

  let currentRoom = null;
  let currentUser = null;

  ws.on('message', (data) => {
    try {
      const message = JSON.parse(data.toString());

      switch (message.type) {
        case 'join_room':
          currentRoom = message.roomId;
          currentUser = message.user;

          if (!whiteboardRooms.has(currentRoom)) {
            whiteboardRooms.set(currentRoom, {
              id: currentRoom,
              clients: [],
              elements: []
            });
            console.log(`?? Salle whiteboard ${currentRoom} crï¿½ï¿½e`);
          }

          const room = whiteboardRooms.get(currentRoom);
          const clientInfo = { ws, user: currentUser };
          room.clients.push(clientInfo);

          console.log(`?? ${currentUser.name} rejoint la salle whiteboard ${currentRoom}`);

          // Envoyer la liste des collaborateurs
          const collaborators = room.clients.map(c => c.user);
          broadcastToWhiteboardRoom(currentRoom, {
            type: 'collaborators_list',
            collaborators
          });

          // Envoyer l'historique
          if (room.elements.length > 0) {
            ws.send(JSON.stringify({
              type: 'canvas_sync',
              elements: room.elements
            }));
          }

          broadcastToWhiteboardRoom(currentRoom, {
            type: 'user_joined',
            user: currentUser
          }, ws);
          break;

        case 'drawing_update':
          if (currentRoom) {
            const room = whiteboardRooms.get(currentRoom);
            if (room) {
              room.elements.push(message.data.element);
              broadcastToWhiteboardRoom(currentRoom, message, ws);
            }
          }
          break;

        case 'cursor_move':
          if (currentRoom) {
            broadcastToWhiteboardRoom(currentRoom, message, ws);
          }
          break;

        case 'canvas_cleared':
          if (currentRoom) {
            const room = whiteboardRooms.get(currentRoom);
            if (room) {
              room.elements = [];
              broadcastToWhiteboardRoom(currentRoom, message, ws);
            }
          }
          break;

        default:
          console.log(`?? Message whiteboard non gï¿½rï¿½: ${message.type}`);
      }
    } catch (error) {
      console.error('? Erreur traitement message whiteboard:', error);
    }
  });

  ws.on('close', () => {
    console.log('?? Connexion whiteboard fermï¿½e');
    if (currentRoom && currentUser) {
      const room = whiteboardRooms.get(currentRoom);
      if (room) {
        room.clients = room.clients.filter(c => c.ws !== ws);
        
        broadcastToWhiteboardRoom(currentRoom, {
          type: 'user_left',
          userId: currentUser.id
        });

        const collaborators = room.clients.map(c => c.user);
        broadcastToWhiteboardRoom(currentRoom, {
          type: 'collaborators_list',
          collaborators
        });

        if (room.clients.length === 0) {
          whiteboardRooms.delete(currentRoom);
          console.log(`??? Salle whiteboard ${currentRoom} supprimï¿½e (vide)`);
        }
      }
    }
  });

  ws.on('error', (error) => {
    console.error('? Erreur WebSocket whiteboard:', error);
  });
}

// Crï¿½er le serveur HTTP
const server = createServer();

// Serveur WebSocket pour Yjs (collaboration texte, commentaires, etc.)
const yjsWss = new WebSocketServer({ 
  server, 
  path: '/yjs' 
});

// Serveur WebSocket pour le whiteboard
const whiteboardWss = new WebSocketServer({ 
  server, 
  path: '/whiteboard' 
});

yjsWss.on('connection', handleYjsConnection);
whiteboardWss.on('connection', handleWhiteboardConnection);

const PORT = process.env.PORT || 3001;
const HOST = process.env.HOST || '0.0.0.0';
server.listen(PORT, HOST, () => {
  console.log(`ðŸš€ Serveur unifiÃ© Synkro dÃ©marrÃ© sur ${HOST}:${PORT}`);
  console.log(`ðŸ“ Collaboration Yjs: ws://localhost:${PORT}/yjs/ROOM_ID`);
  console.log(`ðŸŽ¨ Whiteboard: ws://localhost:${PORT}/whiteboard`);
});

// Gestion propre de l'arrï¿½t
process.on('SIGTERM', () => {
  console.log('?? Arrï¿½t du serveur...');
  yjsWss.close();
  whiteboardWss.close();
  server.close();
});
